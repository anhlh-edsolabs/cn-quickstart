module Fungible.TokenTransferInstruction where

import DA.Foldable (forA_)
import DA.List (null)
import DA.Optional (isNone)
import DA.Time

import Splice.Api.Token.TransferInstructionV1 as Api.Token.TransferInstructionV1
import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import DA.TextMap as TextMap ()

import Fungible.TokenHolding

-- | A transfer instruction for transferring Fungible tokens pending on receiver acceptance.
template TokenTransferInstruction 
  with
    transfer : Api.Token.TransferInstructionV1.Transfer
    status : Api.Token.TransferInstructionV1.TransferInstructionStatus
    meta : Api.Token.MetadataV1.Metadata
  where
    signatory transfer.instrumentId.admin, transfer.sender
    observer transfer.receiver

    -- Implement the TransferInstruction interface
    interface instance Api.Token.TransferInstructionV1.TransferInstruction for TokenTransferInstruction where
      view = Api.Token.TransferInstructionV1.TransferInstructionView with
        originalInstructionCid = None
        transfer
        status
        meta

      transferInstruction_acceptImpl _self arg =
        executeTransferInstr this arg.extraArgs

      transferInstruction_rejectImpl _self arg =
        abortTransferInstruction this arg.extraArgs

      transferInstruction_updateImpl _self _arg =
        fail "TokenTransferInstruction.updateImpl: not used, and thus not implemented"

      transferInstruction_withdrawImpl _self arg = do
        abortTransferInstruction this arg.extraArgs

-- | Execute the transfer instruction by moving tokens from sender to receiver
executeTransferInstr : TokenTransferInstruction -> Api.Token.MetadataV1.ExtraArgs -> Update Api.Token.TransferInstructionV1.TransferInstructionResult
executeTransferInstr instr extraArgs = do
  now <- getTime
  assertMsg "Transfer expired" (instr.transfer.executeBefore > now)
  -- Validate input holdings exist
  assertMsg "Must have input holdings" (not (null instr.transfer.inputHoldingCids))
  
  -- Fetch and validate all input holdings
  inputHoldings <- forA instr.transfer.inputHoldingCids $ \holdingCid -> do
    holding <- fetch @TokenHolding (coerceContractId holdingCid)
    assertMsg "Holding must belong to sender" (holding.owner == instr.transfer.sender)
    assertMsg "Holding must have correct instrument" (holding.instrumentId == instr.transfer.instrumentId)
    assertMsg "Holding must not be locked" (isNone holding.lock)
    pure holding
  
  -- Calculate total available amount and validate sufficient balance
  let totalAvailable = sum $ map (.amount) inputHoldings
  assertMsg "Insufficient balance" (totalAvailable >= instr.transfer.amount)
  
  -- Archive all input holdings
  forA_ instr.transfer.inputHoldingCids archive
  
  -- Calculate change amount
  let senderChangeAmount = totalAvailable - instr.transfer.amount
  
  -- Create change holding for sender (if any)
  senderChangeCids <- if senderChangeAmount > 0.0 
    then do
      changeCid <- create TokenHolding with
        admin = instr.transfer.instrumentId.admin
        owner = instr.transfer.sender
        amount = senderChangeAmount
        instrumentId = instr.transfer.instrumentId
        lock = None
        meta = extraArgs.meta
      pure [toInterfaceContractId changeCid]
    else pure []
  
  -- Create holding for receiver
  receiverHoldingCid <- create TokenHolding with
    admin = instr.transfer.instrumentId.admin
    owner = instr.transfer.receiver
    amount = instr.transfer.amount
    instrumentId = instr.transfer.instrumentId
    lock = None
    meta = extraArgs.meta
  
  -- Return successful transfer result
  pure Api.Token.TransferInstructionV1.TransferInstructionResult with
    senderChangeCids
    output = Api.Token.TransferInstructionV1.TransferInstructionResult_Completed with
      receiverHoldingCids = [toInterfaceContractId receiverHoldingCid]
    meta = extraArgs.meta

-- | Abort the transfer instruction by returning tokens to sender
abortTransferInstruction : TokenTransferInstruction -> Api.Token.MetadataV1.ExtraArgs -> Update Api.Token.TransferInstructionV1.TransferInstructionResult
abortTransferInstruction instr extraArgs = do
  -- Validate that we have the required input holdings
  assertMsg "Must have input holdings" (not (null instr.transfer.inputHoldingCids))
  
  -- Fetch and validate input holdings
  inputHoldings <- forA instr.transfer.inputHoldingCids $ \holdingCid -> do
    holding <- fetch @TokenHolding (coerceContractId holdingCid)
    assertMsg "Holding must belong to sender" (holding.owner == instr.transfer.sender)
    assertMsg "Holding must have correct instrument" (holding.instrumentId == instr.transfer.instrumentId)
    pure holding
  
  -- Archive input holdings
  forA_ instr.transfer.inputHoldingCids $ \holdingCid -> do
    archive holdingCid
  
  -- Calculate total amount to return
  let totalAmount = sum $ map (.amount) inputHoldings
  
  -- Create new holding for sender (return all tokens)
  senderHoldingCid <- create TokenHolding with
    admin = instr.transfer.instrumentId.admin
    owner = instr.transfer.sender
    amount = totalAmount
    instrumentId = instr.transfer.instrumentId
    lock = None
    meta = extraArgs.meta
  
  pure Api.Token.TransferInstructionV1.TransferInstructionResult with
    senderChangeCids = [toInterfaceContractId senderHoldingCid]
    output = Api.Token.TransferInstructionV1.TransferInstructionResult_Failed
    meta = extraArgs.meta