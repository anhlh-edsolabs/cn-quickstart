module Fungible.TokenAllocation where

import DA.Foldable (forA_)
import DA.Optional (isNone)
import DA.Text as Text

import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1

import Fungible.TokenHolding


-- | Allocation of fungible tokens backed by a single locked holding.
template TokenAllocation
  with
    allocation : Api.Token.AllocationV1.AllocationSpecification
    lockedHoldingCid : ContractId TokenHolding
    meta : Api.Token.MetadataV1.Metadata
  where
    signatory allocation.transferLeg.instrumentId.admin, allocation.transferLeg.sender
    observer allocation.settlement.executor

    interface instance Api.Token.AllocationV1.Allocation for TokenAllocation where
      view = Api.Token.AllocationV1.AllocationView with
        allocation = allocation
        holdingCids = [toInterfaceContractId lockedHoldingCid]
        meta = meta

      allocation_executeTransferImpl _self Api.Token.AllocationV1.Allocation_ExecuteTransfer{..} = do
        locked <- fetch lockedHoldingCid
        assertMsg "Locked holding must belong to sender" (locked.owner == allocation.transferLeg.sender)
        assertMsg "Locked holding must have correct instrument" (locked.instrumentId == allocation.transferLeg.instrumentId)
        assertMsg "Locked holding must be locked" (not (isNone locked.lock))

        -- Consume the locked holding
        archive lockedHoldingCid

        -- Create receiver holding
        receiverHoldingCid <- create TokenHolding with
          admin = allocation.transferLeg.instrumentId.admin
          owner = allocation.transferLeg.receiver
          amount = allocation.transferLeg.amount
          instrumentId = allocation.transferLeg.instrumentId
          lock = None
          meta = extraArgs.meta

        pure Api.Token.AllocationV1.Allocation_ExecuteTransferResult with
          senderHoldingCids = []
          receiverHoldingCids = [toInterfaceContractId receiverHoldingCid]
          meta = extraArgs.meta

      allocation_withdrawImpl _self Api.Token.AllocationV1.Allocation_Withdraw{..} = do
        locked <- fetch lockedHoldingCid
        assertMsg "Locked holding must belong to sender" (locked.owner == allocation.transferLeg.sender)
        -- Return funds back to the sender as an unlocked holding
        archive lockedHoldingCid
        senderHoldingCid <- create TokenHolding with
          admin = allocation.transferLeg.instrumentId.admin
          owner = allocation.transferLeg.sender
          amount = locked.amount
          instrumentId = allocation.transferLeg.instrumentId
          lock = None
          meta = extraArgs.meta
        pure Api.Token.AllocationV1.Allocation_WithdrawResult with
          senderHoldingCids = [toInterfaceContractId senderHoldingCid]
          meta = extraArgs.meta

      allocation_cancelImpl _self Api.Token.AllocationV1.Allocation_Cancel{..} = do
        -- Behave like withdraw
        locked <- fetch lockedHoldingCid
        assertMsg "Locked holding must belong to sender" (locked.owner == allocation.transferLeg.sender)
        archive lockedHoldingCid
        senderHoldingCid <- create TokenHolding with
          admin = allocation.transferLeg.instrumentId.admin
          owner = allocation.transferLeg.sender
          amount = locked.amount
          instrumentId = allocation.transferLeg.instrumentId
          lock = None
          meta = extraArgs.meta
        pure Api.Token.AllocationV1.Allocation_CancelResult with
          senderHoldingCids = [toInterfaceContractId senderHoldingCid]
          meta = extraArgs.meta


