module Fungible.TokenTransferFactory where

import DA.Time

import Splice.Api.Token.TransferInstructionV1 as Api.Token.TransferInstructionV1
import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1

import Fungible.TokenTransferInstruction

template TokenTransferFactory with
    admin : Party
    meta: Api.Token.MetadataV1.Metadata
  where
    signatory admin

    -- Implement TransferFactory interface
    interface instance Api.Token.TransferInstructionV1.TransferFactory for TokenTransferFactory where
      view = Api.Token.TransferInstructionV1.TransferFactoryView with
        admin = admin
        meta = meta

      transferFactory_transferImpl _self arg = do
        let Api.Token.TransferInstructionV1.TransferFactory_Transfer {transfer, extraArgs} = arg
        now <- getTime
        
        -- Validate transfer
        assertMsg "Valid instrument" (transfer.instrumentId.admin == admin)
        assertMsg "Positive amount" (transfer.amount > 0.0)
        assertMsg "Valid timing" (transfer.executeBefore > now)
        
        -- Create transfer instruction
        transferInstructionCid <- create TokenTransferInstruction with
          transfer
          status = Api.Token.TransferInstructionV1.TransferPendingReceiverAcceptance
          meta = extraArgs.meta
        
        -- Return pending result
        pure Api.Token.TransferInstructionV1.TransferInstructionResult with
          senderChangeCids = []
          output = Api.Token.TransferInstructionV1.TransferInstructionResult_Pending with
            transferInstructionCid = toInterfaceContractId transferInstructionCid
          meta = extraArgs.meta

      transferFactory_publicFetchImpl _self arg = do
        -- Validate that the expected admin matches the actual admin
        assertMsg "Expected admin must match actual admin" (arg.expectedAdmin == admin)
        -- Return the factory view
        pure (view $ toInterface @Api.Token.TransferInstructionV1.TransferFactory this)
