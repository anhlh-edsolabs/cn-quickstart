module Fungible.TokenAllocationFactory where

import Splice.Api.Token.AllocationInstructionV1 as Api.Token.AllocationInstructionV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import DA.Action (foldlA)
import DA.Optional (isNone)
import DA.List (null)
import DA.Time
import DA.Text as Text

import Fungible.TokenHolding
import Fungible.TokenAllocation

template TokenAllocationFactory
  with
    admin : Party
    meta : Api.Token.MetadataV1.Metadata
  where
    signatory admin

    -- Implement AllocationFactory interface
    interface instance Api.Token.AllocationInstructionV1.AllocationFactory for TokenAllocationFactory where
      view = Api.Token.AllocationInstructionV1.AllocationFactoryView with
        admin = admin
        meta = meta

      allocationFactory_allocateImpl _self Api.Token.AllocationInstructionV1.AllocationFactory_Allocate{..} = do
        now <- getTime
        assertMsg "Expected admin must match actual admin" (expectedAdmin == admin)
        assertMsg "Valid instrument" (allocation.transferLeg.instrumentId.admin == admin)
        assertMsg "Valid timing" (allocation.settlement.allocateBefore > now)

        -- Lock funds: sum the provided holdings, archive them, and create a single locked holding
        -- If no inputs specified, fail (we keep implementation simple)
        assertMsg "Must provide input holdings" (not (null inputHoldingCids))

        -- Fetch holdings and validations, accumulating total amount while archiving
        total <- foldlA (\acc cid -> do
          holding <- fetch @TokenHolding (coerceContractId cid)
          assertMsg "Holding must belong to sender" (holding.owner == allocation.transferLeg.sender)
          assertMsg "Holding must have correct instrument" (holding.instrumentId == allocation.transferLeg.instrumentId)
          assertMsg "Holding must be unlocked" (isNone holding.lock)
          archive cid
          pure (acc + holding.amount)) 0.0 inputHoldingCids

        assertMsg "Insufficient balance for allocation" (total >= allocation.transferLeg.amount)

        -- Create change back to sender if any
        senderChangeCids <- if total > allocation.transferLeg.amount then do
          changeCid <- create TokenHolding with
            admin = admin
            owner = allocation.transferLeg.sender
            amount = total - allocation.transferLeg.amount
            instrumentId = allocation.transferLeg.instrumentId
            lock = None
            meta = extraArgs.meta
          pure [toInterfaceContractId changeCid]
        else pure []

        -- Create a locked holding representing the allocated amount
        let allocLock = Some Api.Token.HoldingV1.Lock with
              holders = [allocation.settlement.executor]
              expiresAt = Some allocation.settlement.settleBefore
              expiresAfter = None
              context = Some (Text.implode ["allocation for transfer leg ", show allocation.transferLegId, " to ", show allocation.transferLeg.receiver])
        lockedCid <- create TokenHolding with
          admin = admin
          owner = allocation.transferLeg.sender
          amount = allocation.transferLeg.amount
          instrumentId = allocation.transferLeg.instrumentId
          lock = allocLock
          meta = extraArgs.meta

        -- Create allocation contract pointing at the locked holding
        allocationCid <- create TokenAllocation with
          allocation
          lockedHoldingCid = lockedCid
          meta = extraArgs.meta

        pure Api.Token.AllocationInstructionV1.AllocationInstructionResult with
          output = Api.Token.AllocationInstructionV1.AllocationInstructionResult_Completed with
            allocationCid = toInterfaceContractId allocationCid
          senderChangeCids = senderChangeCids
          meta = extraArgs.meta

      allocationFactory_publicFetchImpl _self Api.Token.AllocationInstructionV1.AllocationFactory_PublicFetch{..} = do
        assertMsg "Expected admin must match actual admin" (expectedAdmin == admin)
        pure (view $ toInterface @Api.Token.AllocationInstructionV1.AllocationFactory this)