module FungibleTokenTest where

import Daml.Script
import DA.Time
import DA.Action (unless, void)
-- import DA.TextMap qualified as TextMap

import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.MetadataV1
import Splice.Testing.Utils (emptyExtraArgs, queryDisclosure', submitWithDisclosures')
import Splice.Api.Token.TransferInstructionV1 as Api.Token.TransferInstructionV1

-- Use the exchange package Fungible module implementations
import Fungible.TokenHolding
import Fungible.TokenTransferFactory
-- import Fungible.TokenTransferInstruction


-- | End-to-end test for simple Fungible token issuance and direct transfers among alice, bob, and charlie.
testFungibleIssuanceAndTransfer : Script ()
testFungibleIssuanceAndTransfer = script do
  -- parties
  admin <- allocatePartyByHint (PartyIdHint "fungible-admin")
  alice <- allocatePartyByHint (PartyIdHint "alice")
  bob <- allocatePartyByHint (PartyIdHint "bob")
  charlie <- allocatePartyByHint (PartyIdHint "charlie")

  -- instrument id
  let instrumentId = Api.Token.HoldingV1.InstrumentId with admin; id = "FUNGIBLE"
  let emptyMeta = emptyMetadata

  -- create a factory for transfers
  transferFactoryCid <- submit admin $ createCmd TokenTransferFactory with admin; meta = emptyMeta
  factoryDisc <- queryDisclosure' @TokenTransferFactory admin transferFactoryCid

  -- mint/issue: create initial holdings for alice, bob, charlie (simple direct creates)
  void $ submitMulti [admin, alice] [] $ createCmd TokenHolding with admin; owner = alice; amount = 100.0; instrumentId; lock = None; meta = emptyMeta
  void $ submitMulti [admin, bob] [] $ createCmd TokenHolding with admin; owner = bob; amount = 50.0; instrumentId; lock = None; meta = emptyMeta
  void $ submitMulti [admin, charlie] [] $ createCmd TokenHolding with admin; owner = charlie; amount = 1.0; instrumentId; lock = None; meta = emptyMeta

  -- direct transfer: alice -> bob, 10
  now <- getTime
  aliceHoldings <- queryInterface @Api.Token.HoldingV1.Holding alice
  let aliceHoldingCids = [ cid | (cid, Some hv) <- aliceHoldings, hv.instrumentId == instrumentId, hv.owner == alice ]
  let transfer1 = Api.Token.TransferInstructionV1.Transfer with
        sender = alice
        receiver = bob
        amount = 10.0
        instrumentId
        requestedAt = now
        executeBefore = now `addRelTime` days 1
        inputHoldingCids = aliceHoldingCids
        meta = emptyMeta
  res1 <- submitWithDisclosures' alice factoryDisc $ exerciseCmd (toInterfaceContractId @Api.Token.TransferInstructionV1.TransferFactory transferFactoryCid) Api.Token.TransferInstructionV1.TransferFactory_Transfer with
    expectedAdmin = admin
    transfer = transfer1
    extraArgs = emptyExtraArgs
  let res1' : Api.Token.TransferInstructionV1.TransferInstructionResult = res1
  instr1Cid <- case res1'.output of
    Api.Token.TransferInstructionV1.TransferInstructionResult_Pending {transferInstructionCid} -> pure transferInstructionCid
    Api.Token.TransferInstructionV1.TransferInstructionResult_Completed _ -> abort "unexpected completed result"
    Api.Token.TransferInstructionV1.TransferInstructionResult_Failed -> abort "unexpected failed result"
  -- receiver accepts
  _ <- submitMulti [bob, alice, admin] [] $ exerciseCmd instr1Cid Api.Token.TransferInstructionV1.TransferInstruction_Accept with
    extraArgs = emptyExtraArgs

  -- direct transfer: bob -> charlie, 20
  bobHoldings <- queryInterface @Api.Token.HoldingV1.Holding bob
  let bobHoldingCids = [ cid | (cid, Some hv) <- bobHoldings, hv.instrumentId == instrumentId, hv.owner == bob, hv.lock == None ]
  let transfer2 = Api.Token.TransferInstructionV1.Transfer with
        sender = bob
        receiver = charlie
        amount = 20.0
        instrumentId
        requestedAt = now
        executeBefore = now `addRelTime` days 1
        inputHoldingCids = bobHoldingCids
        meta = emptyMeta
  res2 <- submitWithDisclosures' bob factoryDisc $ exerciseCmd (toInterfaceContractId @Api.Token.TransferInstructionV1.TransferFactory transferFactoryCid) Api.Token.TransferInstructionV1.TransferFactory_Transfer with
    expectedAdmin = admin
    transfer = transfer2
    extraArgs = emptyExtraArgs
  let res2' : Api.Token.TransferInstructionV1.TransferInstructionResult = res2
  instr2Cid <- case res2'.output of
    Api.Token.TransferInstructionV1.TransferInstructionResult_Pending {transferInstructionCid} -> pure transferInstructionCid
    Api.Token.TransferInstructionV1.TransferInstructionResult_Completed _ -> abort "unexpected completed result"
    Api.Token.TransferInstructionV1.TransferInstructionResult_Failed -> abort "unexpected failed result"
  -- receiver accepts
  _ <- submitMulti [charlie, bob, admin] [] $ exerciseCmd instr2Cid Api.Token.TransferInstructionV1.TransferInstruction_Accept with
    extraArgs = emptyExtraArgs

  -- assertions
  let balanceOf p = do
        hs <- queryInterface @Api.Token.HoldingV1.Holding p
        let sameInstr = [ hv.amount | (_, Some hv) <- hs, hv.instrumentId == instrumentId, hv.owner == p ]
        pure (sum sameInstr)
  aliceBal <- balanceOf alice
  bobBal <- balanceOf bob
  charlieBal <- balanceOf charlie

  -- after transfers: alice 90, bob 40, charlie 21
  unless (abs (aliceBal - 90.0) < 0.001) $ abort ("unexpected alice balance: " <> show aliceBal)
  unless (abs (bobBal - 40.0) < 0.001) $ abort ("unexpected bob balance: " <> show bobBal)
  unless (abs (charlieBal - 21.0) < 0.001) $ abort ("unexpected charlie balance: " <> show charlieBal)

  pure ()


