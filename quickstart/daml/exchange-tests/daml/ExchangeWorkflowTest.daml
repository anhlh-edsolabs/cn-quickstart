module ExchangeWorkflowTest where

import Daml.Script
import DA.Action (unless, void)
import Exchange.ExchangeWorkflow

import Splice.Scripts.Util
import Splice.Wallet.Payment

-- | Placeholder for exchange workflow test scripts 
test : Script ()
test = do
    app@ExchangeApp{..} <- setupExchangeApp
    
    -- setup exchange workflow
    debug $ "alice: " <> show app.alice
    debug $ "liquidityPool: " <> show app.liquidityPool

    void $ tap amuletApp alice 100.0
    void $ tap amuletApp liquidityPool 10000.0

    -- TODO: add test cases
    pure ()

data ExchangeApp = ExchangeApp with
    dso: Party
    amuletApp: AmuletApp
    provider: AmuletUser
    alice: AmuletUser
    liquidityPool: AmuletUser

setupExchangeApp: Script ExchangeApp
setupExchangeApp = do
    DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
    provider <- setupValidatorParty app "provider"
    -- liquidityPool <- setupUser app "liquidityPool" provider.primaryParty
    liquidityPool <- setupValidatorParty app "liquidityPool"
    featureApp app provider

    pure $ ExchangeApp with
        dso = app.dso
        amuletApp = app
        provider = provider
        alice = alice
        liquidityPool = liquidityPool

-- | Simulate the setup of the validator party on a self-hosted validator node.
setupValidatorParty : AmuletApp -> Text -> Script AmuletUser
setupValidatorParty app name = do
  party  <- allocatePartyByHint (PartyIdHint name)
  userId <- validateUserId name
  -- We need 'CanReadAs app.dso' only in tests, as they are not yet setup to simulate explicit disclosure.
  -- In the actual implementation, the provider backend would provide the DSO published contracts via explicit disclosure.
  -- TODO: get rid of this hack as part of the CN token standard integration
  createUser (User userId (Some party)) [CanActAs party, CanReadAs app.dso]
  -- the validator party is its own validator and can thus claim all its validator rewards
  recordValidatorOf app party party
  pure $ AmuletUser userId party